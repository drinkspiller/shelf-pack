{"version":3,"file":"shelf-pack.min.js","sources":["../../src/index.ts"],"sourcesContent":["/**\n * @fileoverview\n *\n * ShelfPack is a JavaScript library for efficiently packing rectangular items\n * (bins) into a larger container (sprite) using a bin packing algorithm. It\n * employs the Shelf Best Height Fit strategy to minimize wasted space.\n *\n * An Analogy: The Bookshelf\n *\n * Imagine a ShelfPack instance as managing a physical bookshelf:\n *\n *     - `ShelfPack` instance: entire bookshelf.\n *     - `this.shelves`: The horizontal shelves on the bookshelf.\n *     - `Bin` objects: The rectangular items (e.g., books) being placed on the\n *        shelves.\n *     - `this.freebins`: A box of \"available\" books that have been removed\n *        from the shelf and can be reused.\n *     - `this.bins`: A record of all the books currently placed on the\n *        bookshelf, and how many times each has been requested.\n *\n * # Core Concepts:\n *\n * ## Bins\n *  Bins (e.g. 'items', 'elements', 'books') represent an occupied space of a\n * certain size. Each bin has a width (`width`), height (`height`), and a unique\n * identifier (`id`). Think of `this.bins` as a bookshelf with books on it.\n *\n * ## Shelves\n * Shelves are _Horizontal Rows_ within the container where bins are placed.\n * New shelves are created as needed to accommodate bins that don't fit on\n * existing shelves. Think of `this.shelves` as, er, the 'shelves' on a\n * bookshelf.\n *\n * ## Freebins\n * Freebins are a list of previously allocated bins that have been released\n * (i.e. have `refcount === 0`) and are available for reuse. Think of `freebins`\n *  as books that were taken off the shelf and put into a special\n * \"available books\" box (`this.freebins`). The space these books recently\n * occupied can be checked for fit when another book is being placed on a shelf.\n * If it fits, the book can be placed there.\n *\n * ## Shelf Best Height Fit\n * The algorithm prioritizes:\n *      1. Reusing existing `freebins` if they are an exact match or have\n *         minimal wasted space.\n *      2. Placing bins on shelves with the closest matching height to minimize\n *         wasted vertical space.\n *      3. Creating new shelves as needed.\n *\n * ## Auto Resize\n * If enabled (`{autoResize: true}`), the container will automatically grow to\n * accommodate bins that don't fit within the current dimensions.\n *\n * ## Refcounting\n * Reference counting Bins keeps track of how many a bin has been allocated.\n * Use `.ref()` to increment and `.unref()` to decrement the count. When the\n * count reaches 0, the bin is freed.\n *\n * # Usage\n *\n * 1. Create a ShelfPack instance\n *    `const packer = new ShelfPack(width, height, options);`\n * 2. Pack bins\n *    `packer.pack(bins, options);` or `packer.packOne(width, height, id);`\n * 3. Retrieve a bin\n *    `packer.getBin(id);`\n * 4. Manage bin references\n *    `packer.ref(bin);` and `packer.unref(bin);`\n * 5. Resize the container\n *    `packer.resize(width, height);`\n * 6. Clear the container\n *    `packer.clear();`\n */\n\n/**\n * Options for configuring the ShelfPack instance.\n */\nexport interface ShelfPackOptions {\n  /**\n   * If true, the packer will automatically grow its dimensions to accommodate\n   * bins that don't fit.\n   */\n  autoResize?: boolean;\n}\n\nexport interface BinOptions {\n  inPlace?: boolean;\n  shrinkAfterPack?: boolean;\n}\n\nexport interface BinInterface {\n  id: string | number;\n  width: number;\n  height: number;\n  options?: BinOptions;\n}\n\n/**\n * Represents a rectangular area within the packer.\n */\nexport class Bin implements BinInterface {\n  id: string | number;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  maxwidth: number;\n  maxheight: number;\n  refcount: number;\n  /**\n   * Creates a new Bin instance.\n   * @param id Unique identifier for the bin.\n   * @param x Left coordinate of the bin.\n   * @param y Top coordinate of the bin.\n   * @param width Width of the bin.\n   * @param height Height of the bin.\n   * @param maxwidth Maximum width the bin can occupy.\n   * @param maxheight Maximum height the bin can occupy.\n   * @param refcount The number of references to this bin.\n   */\n  constructor(\n    id: string | number,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    maxwidth: number = width,\n    maxheight: number = height,\n    refcount: number = 0,\n  ) {\n    this.id = id;\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.maxwidth = maxwidth;\n    this.maxheight = maxheight;\n    this.refcount = refcount;\n  }\n}\n\n/**\n * Represents a horizontal row within the packer where bins can be placed.\n */\nexport class Shelf {\n  y: number;\n  width: number;\n  height: number;\n  x: number;\n  free: number;\n  /**\n   * Creates a new Shelf instance.\n   * @param y Top coordinate of the shelf.\n   * @param width Width of the shelf.\n   * @param height Height of the shelf.\n   * @param x The initial X position on the shelf\n   */\n  constructor(y: number, width: number, height: number, x: number = 0) {\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.x = x;\n    this.free = width;\n  }\n\n  /**\n   * Attempts to allocate a bin on this shelf.\n   * @param width Width of the bin to allocate.\n   * @param height Height of the bin to allocate.\n   * @param id Unique identifier for the bin.\n   * @returns The allocated Bin, or null if allocation failed.\n   */\n  allocateBin(width: number, height: number, id: string | number): Bin | null {\n    if (width > this.free || height > this.height) {\n      return null;\n    }\n    const x = this.x;\n    this.x += width;\n    this.free -= width;\n    return new Bin(id, x, this.y, width, height, width, this.height);\n  }\n\n  /**\n   * Resizes the shelf to a new width.\n   * @param width The new width of the shelf.\n   */\n  resize(width: number): void {\n    this.free += width - this.width;\n    this.width = width;\n  }\n}\n\n/**\n * A bin packing algorithm that uses the Shelf Best Height Fit strategy.\n */\nexport class ShelfPack {\n  /**\n   * If true, the packer will automatically grow its dimensions to accommodate\n   * bins that don't fit.\n   */\n  autoResize: boolean;\n  /**\n   * The list of shelves in the packer.\n   */\n  shelves: Shelf[];\n  /**\n   * The list of free bins available for reuse.\n   */\n  freebins: Bin[];\n  /**\n   * Statistics about the packed bins.\n   */\n  stats: Record<number, number>;\n  /**\n   * A map of packed bins, indexed by their unique identifiers.\n   */\n  bins: Record<string | number, Bin>;\n  /**\n   * The maximum ID used for a bin.\n   */\n  maxId: number;\n  /**\n   * The current width of the packer\n   */\n  width: number;\n  /**\n   * The current height of the packer\n   */\n  height: number;\n  /**\n   * Creates a new ShelfPack instance.\n   * @param width Initial width of the packer.\n   * @param height Initial height of the packer.\n   * @param options Optional configuration options.\n   */\n  constructor(\n    width: number = 64,\n    height: number = 64,\n    options?: ShelfPackOptions,\n  ) {\n    const opts = options ?? {};\n    this.autoResize = !!opts.autoResize;\n    this.shelves = [];\n    this.freebins = [];\n    this.stats = {};\n    this.bins = {};\n    this.maxId = 0;\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * Packs multiple bins into the packer.\n   * @param bins An array of bins to pack. Each bin should have `width` and `height` properties.\n   * @param options Optional parameters.\n   * @param options.inPlace If true, modifies the input `bins` array in-place, adding `x`, `y`, and `id` properties to each bin.\n   * @returns An array of packed Bins.\n   */\n  pack(\n    bins: Bin[],\n    options: BinOptions = { inPlace: false, shrinkAfterPack: true },\n  ): Bin[] {\n    const updatedBins = bins as Bin[];\n\n    const results = [];\n    let width: number;\n    let height: number;\n    let id: string | number;\n    let allocation: Bin | null;\n\n    for (let i = 0; i < updatedBins.length; i++) {\n      width = updatedBins[i].width;\n      height = updatedBins[i].height;\n      id = updatedBins[i].id;\n\n      if (width && height) {\n        allocation = this.packOne(width, height, id);\n\n        if (!allocation) {\n          continue;\n        }\n\n        if (options.inPlace) {\n          updatedBins[i].x = allocation.x;\n          updatedBins[i].y = allocation.y;\n          updatedBins[i].id = allocation.id;\n        }\n        results.push(allocation);\n      }\n    }\n\n    if (options.shrinkAfterPack) {\n      this.shrink();\n    }\n\n    return results;\n  }\n\n  /**\n   * Packs a single bin into the packer.\n   * @param width Width of the bin to pack.\n   * @param height Height of the bin to pack.\n   * @param id Optional unique identifier for the bin. If not provided, a new ID will be generated.\n   * @returns The packed Bin, or null if the bin could not be packed.\n   */\n  packOne(width: number, height: number, id?: string | number): Bin | null {\n    const best: { freebin: number; shelf: number; waste: number } = {\n      freebin: -1,\n      shelf: -1,\n      waste: Infinity,\n    };\n    let y = 0;\n    let bin: Bin | undefined;\n    let shelf: Shelf | undefined;\n    let waste: number;\n    let i: number;\n    let finalId: string | number;\n\n    // If id was supplied, attempt a lookup.\n    if (typeof id === \"string\" || typeof id === \"number\") {\n      bin = this.getBin(id);\n      if (bin) {\n        // We packed this bin already.\n        this.incrementReferenceCount(bin);\n        return bin;\n      }\n      finalId = id;\n    } else {\n      finalId = ++this.maxId;\n    }\n\n    // First try to reuse a free bin.\n    for (i = 0; i < this.freebins.length; i++) {\n      bin = this.freebins[i];\n\n      // Exactly the right height and width, use it.\n      if (height === bin.maxheight && width === bin.maxwidth) {\n        return this.allocateFreeBin(i, width, height, finalId);\n      }\n      // Not enough height or width, skip it.\n      if (height > bin.maxheight || width > bin.maxwidth) {\n        continue;\n      }\n      // Extra height or width, minimize wasted area.\n      if (height <= bin.maxheight && width <= bin.maxwidth) {\n        waste = bin.maxwidth * bin.maxheight - width * height;\n        if (waste < best.waste) {\n          best.waste = waste;\n          best.freebin = i;\n        }\n      }\n    }\n\n    // Next find the best shelf.\n    for (i = 0; i < this.shelves.length; i++) {\n      shelf = this.shelves[i];\n      y += shelf.height;\n\n      // Not enough width on this shelf, skip it.\n      if (width > shelf.free) {\n        continue;\n      }\n      // Exactly the right height, pack it.\n      if (height === shelf.height) {\n        return this.allocShelf(i, width, height, finalId);\n      }\n      // Not enough height, skip it.\n      if (height > shelf.height) {\n        continue;\n      }\n      // Extra height, minimize wasted area.\n      if (height < shelf.height) {\n        waste = (shelf.height - height) * width;\n        if (waste < best.waste) {\n          best.freebin = -1;\n          best.waste = waste;\n          best.shelf = i;\n        }\n      }\n    }\n\n    if (best.freebin !== -1) {\n      return this.allocateFreeBin(best.freebin, width, height, finalId);\n    }\n\n    if (best.shelf !== -1) {\n      return this.allocShelf(best.shelf, width, height, finalId);\n    }\n\n    // No free bins or shelves. Add shelf.\n    if (height <= this.height - y && width <= this.width) {\n      shelf = new Shelf(y, this.width, height);\n      return this.allocShelf(\n        this.shelves.push(shelf) - 1,\n        width,\n        height,\n        finalId,\n      );\n    }\n\n    // No room for more shelves.\n    // If `autoResize` option is set, grow the sprite as follows:\n    //  * double whichever sprite dimension is smaller (`width1` or `height1`)\n    //  * if sprite dimensions are equal, grow width before height\n    //  * accommodate very large bin requests (big `width` or `height`)\n    if (this.autoResize) {\n      let height1: number, height2: number, width1: number, width2: number;\n\n      height1 = height2 = this.height;\n      width1 = width2 = this.width;\n\n      if (width1 <= height1 || width > width1) {\n        // Grow width.\n        width2 = Math.max(width, width1) * 2;\n      }\n      if (height1 < width1 || height > height1) {\n        // Grow height.\n        height2 = Math.max(height, height1) * 2;\n      }\n\n      this.resize(width2, height2);\n      return this.packOne(width, height, finalId); // Retry.\n    }\n\n    return null;\n  }\n\n  /**\n   * Allocates a bin by reusing an existing free bin.\n   * @param index The index of the free bin in the `freebins` array.\n   * @param width The width of the bin to allocate.\n   * @param height The height of the bin to allocate.\n   * @param id The unique identifier for the bin.\n   * @returns The allocated Bin.\n   */\n  private allocateFreeBin(\n    index: number,\n    width: number,\n    height: number,\n    id: string | number,\n  ): Bin {\n    const bin = this.freebins.splice(index, 1)[0];\n    const newBin = new Bin(\n      id,\n      bin.x,\n      bin.y,\n      width,\n      height,\n      bin.maxwidth,\n      bin.maxheight,\n      0,\n    );\n    this.bins[id] = newBin;\n    this.incrementReferenceCount(newBin);\n    return newBin;\n  }\n\n  /**\n   * Allocates a bin on an existing shelf.\n   * @param index The index of the shelf in the `shelves` array.\n   * @param width The width of the bin to allocate.\n   * @param height The height of the bin to allocate.\n   * @param id The unique identifier for the bin.\n   * @returns The allocated Bin.\n   */\n  private allocShelf(\n    index: number,\n    width: number,\n    height: number,\n    id: string | number,\n  ): Bin {\n    const shelf = this.shelves[index];\n    const bin = shelf.allocateBin(width, height, id);\n    if (bin === null) {\n      throw new Error(\"Failed to allocate bin on shelf.\");\n    }\n    this.bins[id] = bin;\n    this.incrementReferenceCount(bin);\n    return bin;\n  }\n\n  /**\n   * Shrinks the width/height of the sprite to the bare minimum.\n   * Since shelf-pack doubles first width, then height when running out of shelf space\n   * this can result in fairly large unused space both in width and height if that happens\n   * towards the end of bin packing.\n   */\n  shrink(): void {\n    if (this.shelves.length > 0) {\n      let width2 = 0;\n      let height2 = 0;\n\n      for (let j = 0; j < this.shelves.length; j++) {\n        const shelf = this.shelves[j];\n        height2 += shelf.height;\n        width2 = Math.max(shelf.width - shelf.free, width2);\n      }\n\n      this.resize(width2, height2);\n    }\n  }\n\n  /**\n   * Retrieves a packed bin by its ID.\n   * @param id The unique identifier of the bin.\n   * @returns The Bin, or undefined if no bin with the given ID is found.\n   */\n  getBin(id: string | number): Bin | undefined {\n    return this.bins[id];\n  }\n\n  /**\n   * Increments the reference count of a bin.\n   * @param bin The bin to increment the reference count of.\n   * @returns The new reference count of the bin.\n   */\n  incrementReferenceCount(bin: Bin): number {\n    if (++bin.refcount === 1) {\n      // A new Bin. record height in stats histogram.\n      this.stats[bin.height] = (this.stats[bin.height] | 0) + 1;\n    }\n\n    return bin.refcount;\n  }\n\n  /**\n   * Decrements the reference count of a bin.\n   * If the reference count reaches 0, the bin is added to the `freebins` list\n   * and removed from `bins`.\n   * @param bin The bin to decrement the reference count of.\n   * @returns The new reference count of the bin.\n   */\n  decrementReferenceCount(bin: Bin): number {\n    if (bin.refcount === 0) {\n      return 0;\n    }\n\n    if (--bin.refcount === 0) {\n      this.stats[bin.height]--;\n      delete this.bins[bin.id];\n      this.freebins.push(bin);\n    }\n\n    return bin.refcount;\n  }\n\n  /**\n   * Clears the packer, removing all bins and shelves.\n   */\n  clear(): void {\n    this.shelves = [];\n    this.freebins = [];\n    this.stats = {};\n    this.bins = {};\n    this.maxId = 0;\n  }\n\n  /**\n   * Resizes the packer to the given dimensions.\n   * @param width The new width of the packer.\n   * @param height The new height of the packer.\n   * @returns True if the resize was successful, false otherwise.\n   */\n  resize(width: number, height: number): boolean {\n    this.width = width;\n    this.height = height;\n    for (let i = 0; i < this.shelves.length; i++) {\n      this.shelves[i].resize(width);\n    }\n    return true;\n  }\n}\n"],"names":["Bin","id","x","y","width","height","maxwidth","maxheight","refcount","this","Shelf","free","prototype","allocateBin","resize","ShelfPack","options","opts","autoResize","shelves","freebins","stats","bins","maxId","pack","inPlace","shrinkAfterPack","allocation","updatedBins","results","i","length","packOne","push","shrink","bin","shelf","waste","finalId","best","freebin","Infinity","getBin","incrementReferenceCount","allocateFreeBin","allocShelf","height1","width1","height2","width2","Math","max","index","splice","newBin","Error","j","decrementReferenceCount","clear"],"mappings":"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"}