{"version":3,"file":"shelf-pack.min.js","sources":["../node_modules/tslib/tslib.es6.js","../../src/index.ts"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\r\n    return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nvar ownKeys = function(o) {\r\n    ownKeys = Object.getOwnPropertyNames || function (o) {\r\n        var ar = [];\r\n        for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\r\n        return ar;\r\n    };\r\n    return ownKeys(o);\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose, inner;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n            if (async) inner = dispose;\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    var r, s = 0;\r\n    function next() {\r\n        while (r = env.stack.pop()) {\r\n            try {\r\n                if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\r\n                if (r.dispose) {\r\n                    var result = r.dispose.call(r.value);\r\n                    if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n                }\r\n                else s |= 1;\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\r\n    if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\r\n        return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\r\n            return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\r\n        });\r\n    }\r\n    return path;\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __esDecorate: __esDecorate,\r\n    __runInitializers: __runInitializers,\r\n    __propKey: __propKey,\r\n    __setFunctionName: __setFunctionName,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n    __rewriteRelativeImportExtension: __rewriteRelativeImportExtension,\r\n};\r\n","/**\n * @fileoverview\n *\n * ShelfPack is a JavaScript library for efficiently packing rectangular items\n * (bins) into a larger container (sprite) using a bin packing algorithm. It\n * employs the Shelf Best Height Fit strategy to minimize wasted space.\n *\n * An Analogy: The Bookshelf\n *\n * Imagine a ShelfPack instance as managing a physical bookshelf:\n *\n *     - `ShelfPack` instance: entire bookshelf.\n *     - `this.shelves`: The horizontal shelves on the bookshelf.\n *     - `Bin` objects: The rectangular items (e.g., books) being placed on the\n *        shelves.\n *     - `this.freebins`: A box of \"available\" books that have been removed\n *        from the shelf and can be reused.\n *     - `this.bins`: A record of all the books currently placed on the\n *        bookshelf, and how many times each has been requested.\n *\n * # Core Concepts:\n *\n * ## Bins\n *  Bins (e.g. 'items', 'elements', 'books') represent an occupied space of a\n * certain size. Each bin has a width (`w`), height (`h`), and a unique\n * identifier (`id`). Think of `this.bins` as a bookshelf with books on it.\n *\n * ## Shelves\n * Shelves are _Horizontal Rows_ within the container where bins are placed.\n * New shelves are created as needed to accommodate bins that don't fit on\n * existing shelves. Think of `this.shelves` as, er, the 'shelves' on a\n * bookshelf.\n *\n * ## Freebins\n * Freebins are a list of previously allocated bins that have been released\n * (i.e. have `refcount === 0`) and are available for reuse. Think of `freebins`\n *  as books that were taken off the shelf and put into a special\n * \"available books\" box (`this.freebins`). The space these books recently\n * occupied can be checked for fit when another book is being placed on a shelf.\n * If it fits, the book can be placed there.\n *\n * ## Shelf Best Height Fit\n * The algorithm prioritizes:\n *      1. Reusing existing `freebins` if they are an exact match or have\n *         minimal wasted space.\n *      2. Placing bins on shelves with the closest matching height to minimize\n *         wasted vertical space.\n *      3. Creating new shelves as needed.\n *\n * ## Auto Resize\n * If enabled (`{autoResize: true}`), the container will automatically grow to\n * accommodate bins that don't fit within the current dimensions.\n *\n * ## Refcounting\n * Reference counting Bins keeps track of how many a bin has been allocated.\n * Use `.ref()` to increment and `.unref()` to decrement the count. When the\n * count reaches 0, the bin is freed.\n *\n * # Usage\n *\n * 1. Create a ShelfPack instance\n *    `const packer = new ShelfPack(width, height, options);`\n * 2. Pack bins\n *    `packer.pack(bins, options);` or `packer.packOne(w, h, id);`\n * 3. Retrieve a bin\n *    `packer.getBin(id);`\n * 4. Manage bin references\n *    `packer.ref(bin);` and `packer.unref(bin);`\n * 5. Resize the container\n *    `packer.resize(width, height);`\n * 6. Clear the container\n *    `packer.clear();`\n */\n\n/**\n * Options for configuring the ShelfPack instance.\n */\ninterface ShelfPackOptions {\n  /**\n   * If true, the packer will automatically grow its dimensions to accommodate\n   * bins that don't fit.\n   */\n  autoResize?: boolean;\n}\n\ninterface BinInput {\n  w?: number;\n  h?: number;\n  width?: number;\n  height?: number;\n  id?: string | number;\n}\n\ntype InputBin<T extends { inPlace?: boolean }> = T[\"inPlace\"] extends true\n  ? Bin // If inPlace is true, require Bin type\n  : BinInput; // Otherwise, allow BinInput type\n\n/**\n * Represents a rectangular area within the packer.\n */\nclass Bin {\n  id: string | number;\n  x: number;\n  y: number;\n  w: number;\n  h: number;\n  maxw: number;\n  maxh: number;\n  refcount: number;\n  /**\n   * Creates a new Bin instance.\n   * @param id Unique identifier for the bin.\n   * @param x Left coordinate of the bin.\n   * @param y Top coordinate of the bin.\n   * @param w Width of the bin.\n   * @param h Height of the bin.\n   * @param maxw Maximum width the bin can occupy.\n   * @param maxh Maximum height the bin can occupy.\n   * @param refcount The number of references to this bin.\n   */\n  constructor(\n    id: string | number,\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n    maxw: number = w,\n    maxh: number = h,\n    refcount: number = 0,\n  ) {\n    this.id = id;\n    this.x = x;\n    this.y = y;\n    this.w = w;\n    this.h = h;\n    this.maxw = maxw;\n    this.maxh = maxh;\n    this.refcount = refcount;\n  }\n}\n\n/**\n * Represents a horizontal row within the packer where bins can be placed.\n */\nclass Shelf {\n  y: number;\n  w: number;\n  h: number;\n  x: number;\n  free: number;\n  /**\n   * Creates a new Shelf instance.\n   * @param y Top coordinate of the shelf.\n   * @param width Width of the shelf.\n   * @param height Height of the shelf.\n   * @param x The initial X position on the shelf\n   */\n  constructor(y: number, width: number, height: number, x: number = 0) {\n    this.y = y;\n    this.w = width;\n    this.h = height;\n    this.x = x;\n    this.free = width;\n  }\n\n  /**\n   * Attempts to allocate a bin on this shelf.\n   * @param w Width of the bin to allocate.\n   * @param h Height of the bin to allocate.\n   * @param id Unique identifier for the bin.\n   * @returns The allocated Bin, or null if allocation failed.\n   */\n  alloc(w: number, h: number, id: string | number): Bin | null {\n    if (w > this.free || h > this.h) {\n      return null;\n    }\n    const x = this.x;\n    this.x += w;\n    this.free -= w;\n    return new Bin(id, x, this.y, w, h, w, this.h);\n  }\n\n  /**\n   * Resizes the shelf to a new width.\n   * @param w The new width of the shelf.\n   */\n  resize(w: number): void {\n    this.free += w - this.w;\n    this.w = w;\n  }\n}\n\n/**\n * A bin packing algorithm that uses the Shelf Best Height Fit strategy.\n */\nclass ShelfPack {\n  /**\n   * If true, the packer will automatically grow its dimensions to accommodate\n   * bins that don't fit.\n   */\n  public autoResize: boolean;\n  /**\n   * The list of shelves in the packer.\n   */\n  public shelves: Shelf[];\n  /**\n   * The list of free bins available for reuse.\n   */\n  public freebins: Bin[];\n  /**\n   * Statistics about the packed bins.\n   */\n  public stats: Record<number, number>;\n  /**\n   * A map of packed bins, indexed by their unique identifiers.\n   */\n  public bins: Record<string | number, Bin>;\n  /**\n   * The maximum ID used for a bin.\n   */\n  public maxId: number;\n  /**\n   * The current width of the packer\n   */\n  public w: number;\n  /**\n   * The current height of the packer\n   */\n  public h: number;\n  /**\n   * Creates a new ShelfPack instance.\n   * @param width Initial width of the packer.\n   * @param height Initial height of the packer.\n   * @param options Optional configuration options.\n   */\n  constructor(\n    width: number = 64,\n    height: number = 64,\n    options?: ShelfPackOptions,\n  ) {\n    const opts = options ?? {};\n    this.autoResize = !!opts.autoResize;\n    this.shelves = [];\n    this.freebins = [];\n    this.stats = {};\n    this.bins = {};\n    this.maxId = 0;\n    this.w = width;\n    this.h = height;\n  }\n\n  /**\n   * Packs multiple bins into the packer.\n   * @param bins An array of bins to pack. Each bin should have `w` (or `width`) and `h` (or `height`) properties.\n   * @param options Optional parameters.\n   * @param options.inPlace If true, modifies the input `bins` array in-place, adding `x`, `y`, and `id` properties to each bin.\n   * @returns An array of packed Bins.\n   */\n  pack<T extends { inPlace?: boolean }>(\n    bins: InputBin<T>[],\n    options: T = {} as T,\n  ): Bin[] {\n    const binsCopy = [...bins] as InputBin<T>[];\n\n    const results: Bin[] = [];\n\n    for (let i = 0; i < binsCopy.length; i++) {\n      const w = binsCopy[i].w || binsCopy[i].w;\n      const h = binsCopy[i].h || binsCopy[i].h;\n      const id = binsCopy[i].id;\n\n      if (typeof w === \"number\" && typeof h === \"number\") {\n        const allocation = this.packOne(w, h, id);\n        if (!allocation) {\n          continue;\n        }\n        if (options.inPlace) {\n          if (\"x\" in binsCopy[i] && \"y\" in binsCopy[i]) {\n            const bin = bins[i] as Bin;\n            bin.x = allocation.x;\n            bin.y = allocation.y;\n            bin.id = allocation.id;\n          }\n          results.push(allocation);\n        }\n      }\n    }\n\n    this.shrink();\n\n    return results;\n  }\n\n  /**\n   * Packs a single bin into the packer.\n   * @param w Width of the bin to pack.\n   * @param h Height of the bin to pack.\n   * @param id Optional unique identifier for the bin. If not provided, a new ID will be generated.\n   * @returns The packed Bin, or null if the bin could not be packed.\n   */\n  packOne(w: number, h: number, id?: string | number): Bin | null {\n    const best: { freebin: number; shelf: number; waste: number } = {\n      freebin: -1,\n      shelf: -1,\n      waste: Infinity,\n    };\n    let y = 0;\n    let bin: Bin | undefined;\n    let shelf: Shelf | undefined;\n    let waste: number;\n    let i: number;\n    let finalId: string | number;\n\n    // If id was supplied, attempt a lookup..\n    if (typeof id === \"string\" || typeof id === \"number\") {\n      bin = this.getBin(id);\n      if (bin) {\n        // We packed this bin already.\n        this.ref(bin);\n        return bin;\n      }\n      finalId = id;\n    } else {\n      finalId = ++this.maxId;\n    }\n\n    // First try to reuse a free bin..\n    for (i = 0; i < this.freebins.length; i++) {\n      bin = this.freebins[i];\n\n      // Exactly the right height and width, use it..\n      if (h === bin.maxh && w === bin.maxw) {\n        return this.allocFreebin(i, w, h, finalId);\n      }\n      // Not enough height or width, skip it..\n      if (h > bin.maxh || w > bin.maxw) {\n        continue;\n      }\n      // Extra height or width, minimize wasted area..\n      if (h <= bin.maxh && w <= bin.maxw) {\n        waste = bin.maxw * bin.maxh - w * h;\n        if (waste < best.waste) {\n          best.waste = waste;\n          best.freebin = i;\n        }\n      }\n    }\n\n    // Next find the best shelf..\n    for (i = 0; i < this.shelves.length; i++) {\n      shelf = this.shelves[i];\n      y += shelf.h;\n\n      // Not enough width on this shelf, skip it..\n      if (w > shelf.free) {\n        continue;\n      }\n      // Exactly the right height, pack it..\n      if (h === shelf.h) {\n        return this.allocShelf(i, w, h, finalId);\n      }\n      // Not enough height, skip it..\n      if (h > shelf.h) {\n        continue;\n      }\n      // Extra height, minimize wasted area..\n      if (h < shelf.h) {\n        waste = (shelf.h - h) * w;\n        if (waste < best.waste) {\n          best.freebin = -1;\n          best.waste = waste;\n          best.shelf = i;\n        }\n      }\n    }\n\n    if (best.freebin !== -1) {\n      return this.allocFreebin(best.freebin, w, h, finalId);\n    }\n\n    if (best.shelf !== -1) {\n      return this.allocShelf(best.shelf, w, h, finalId);\n    }\n\n    // No free bins or shelves.. add shelf..\n    if (h <= this.h - y && w <= this.w) {\n      shelf = new Shelf(y, this.w, h);\n      return this.allocShelf(this.shelves.push(shelf) - 1, w, h, finalId);\n    }\n\n    // No room for more shelves..\n    // If `autoResize` option is set, grow the sprite as follows:\n    //  * double whichever sprite dimension is smaller (`w1` or `h1`)\n    //  * if sprite dimensions are equal, grow width before height\n    //  * accommodate very large bin requests (big `w` or `h`)\n    if (this.autoResize) {\n      let h1: number, h2: number, w1: number, w2: number;\n\n      h1 = h2 = this.h;\n      w1 = w2 = this.w;\n\n      if (w1 <= h1 || w > w1) {\n        // Grow width..\n        w2 = Math.max(w, w1) * 2;\n      }\n      if (h1 < w1 || h > h1) {\n        // Grow height..\n        h2 = Math.max(h, h1) * 2;\n      }\n\n      this.resize(w2, h2);\n      return this.packOne(w, h, finalId); // Retry.\n    }\n\n    return null;\n  }\n\n  /**\n   * Allocates a bin by reusing an existing free bin.\n   * @param index The index of the free bin in the `freebins` array.\n   * @param w The width of the bin to allocate.\n   * @param h The height of the bin to allocate.\n   * @param id The unique identifier for the bin.\n   * @returns The allocated Bin.\n   */\n  private allocFreebin(\n    index: number,\n    w: number,\n    h: number,\n    id: string | number,\n  ): Bin {\n    const bin = this.freebins.splice(index, 1)[0];\n    const newBin = new Bin(id, bin.x, bin.y, w, h, bin.maxw, bin.maxh, 0);\n    this.bins[id] = newBin;\n    this.ref(newBin);\n    return newBin;\n  }\n\n  /**\n   * Allocates a bin on an existing shelf.\n   * @param index The index of the shelf in the `shelves` array.\n   * @param w The width of the bin to allocate.\n   * @param h The height of the bin to allocate.\n   * @param id The unique identifier for the bin.\n   * @returns The allocated Bin.\n   */\n  private allocShelf(\n    index: number,\n    w: number,\n    h: number,\n    id: string | number,\n  ): Bin {\n    const shelf = this.shelves[index];\n    const bin = shelf.alloc(w, h, id);\n    if (bin === null) {\n      throw new Error(\"Failed to allocate bin on shelf.\");\n    }\n    this.bins[id] = bin;\n    this.ref(bin);\n    return bin;\n  }\n\n  /**\n   * Shrinks the width/height of the sprite to the bare minimum.\n   * Since shelf-pack doubles first width, then height when running out of shelf space\n   * this can result in fairly large unused space both in width and height if that happens\n   * towards the end of bin packing.\n   */\n  shrink(): void {\n    if (this.shelves.length > 0) {\n      let w2 = 0;\n      let h2 = 0;\n\n      for (let j = 0; j < this.shelves.length; j++) {\n        const shelf = this.shelves[j];\n        h2 += shelf.h;\n        w2 = Math.max(shelf.w - shelf.free, w2);\n      }\n\n      this.resize(w2, h2);\n    }\n  }\n\n  /**\n   * Retrieves a packed bin by its ID.\n   * @param id The unique identifier of the bin.\n   * @returns The Bin, or undefined if no bin with the given ID is found.\n   */\n  getBin(id: string | number): Bin | undefined {\n    return this.bins[id];\n  }\n\n  /**\n   * Increments the reference count of a bin.\n   * @param bin The bin to increment the reference count of.\n   * @returns The new reference count of the bin.\n   */\n  ref(bin: Bin): number {\n    if (++bin.refcount === 1) {\n      // A new Bin.. record height in stats histogram..\n      this.stats[bin.h] = (this.stats[bin.h] | 0) + 1;\n    }\n\n    return bin.refcount;\n  }\n\n  /**\n   * Decrements the reference count of a bin.\n   * If the reference count reaches 0, the bin is added to the `freebins` list\n   * and removed from `bins`.\n   * @param bin The bin to decrement the reference count of.\n   * @returns The new reference count of the bin.\n   */\n  unref(bin: Bin): number {\n    if (bin.refcount === 0) {\n      return 0;\n    }\n\n    if (--bin.refcount === 0) {\n      this.stats[bin.h]--;\n      delete this.bins[bin.id];\n      this.freebins.push(bin);\n    }\n\n    return bin.refcount;\n  }\n\n  /**\n   * Clears the packer, removing all bins and shelves.\n   */\n  clear(): void {\n    this.shelves = [];\n    this.freebins = [];\n    this.stats = {};\n    this.bins = {};\n    this.maxId = 0;\n  }\n\n  /**\n   * Resizes the packer to the given dimensions.\n   * @param w The new width of the packer.\n   * @param h The new height of the packer.\n   * @returns True if the resize was successful, false otherwise.\n   */\n  resize(w: number, h: number): boolean {\n    this.w = w;\n    this.h = h;\n    for (let i = 0; i < this.shelves.length; i++) {\n      this.shelves[i].resize(w);\n    }\n    return true;\n  }\n}\n\nexport default ShelfPack;\n"],"names":["SuppressedError","Bin","id","x","y","w","h","maxw","maxh","refcount","this","Shelf","width","height","free","prototype","alloc","resize","ShelfPack","options","opts","autoResize","shelves","freebins","stats","bins","maxId","pack","binsCopy","to","from","arguments","length","ar","i","l","Array","slice","call","concat","__spreadArray","results","allocation","packOne","inPlace","bin","push","shrink","shelf","waste","finalId","best","freebin","Infinity","getBin","ref","allocFreebin","allocShelf","h1","w1","h2","w2","Math","max","index","splice","newBin","Error","j","unref","clear"],"mappings":"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","x_google_ignoreList":[0]}