{"version":3,"file":"shelf-pack.min.js","sources":["../../src/index.ts"],"sourcesContent":["/**\n * @fileoverview\n *\n * ShelfPack is a JavaScript library for efficiently packing rectangular items\n * (bins) into a larger container (sprite) using a bin packing algorithm. It\n * employs the Shelf Best Height Fit strategy to minimize wasted space.\n *\n * An Analogy: The Bookshelf\n *\n * Imagine a ShelfPack instance as managing a physical bookshelf:\n *\n *   - `ShelfPack` instance: entire bookshelf.\n *   - `this.shelves`: The horizontal shelves on the bookshelf.\n *   - `Bin` objects: The rectangular items (e.g., books) being placed on the\n *        shelves.\n *   - `this.freebins`: Available spots on a shelf where a removed book used to\n *      be and can be reused.\n *   - `this.bins`: A record of all the books currently placed on the\n *      bookshelf, and how many times each has been requested.\n *\n * # Core Concepts:\n *\n * ## Bins\n *  Bins (e.g. 'items', 'elements', 'books') represent an occupied space of a\n * certain size. Each bin has a width (`width`), height (`height`), and a unique\n * identifier (`id`). Think of `this.bins` as a bookshelf with books on it.\n *\n * ## Shelves\n * Shelves are _Horizontal Rows_ within the container where bins are placed.\n * New shelves are created as needed to accommodate bins that don't fit on\n * existing shelves. Think of `this.shelves` as, er, the 'shelves' on a\n * bookshelf.\n *\n * ## Freebins\n * Freebins are a list of previously allocated bins that have been released\n * (i.e. have `refcount === 0`) and are available for reuse. Think of `freebins`\n *  as books that were taken off the shelf and put into a special\n * \"available books\" box (`this.freebins`). The space these books recently\n * occupied can be checked for fit when another book is being placed on a shelf.\n * If it fits, the book can be placed there.\n *\n * ## Shelf Best Height Fit\n * The algorithm prioritizes:\n *      1. Reusing existing `freebins` if they are an exact match or have\n *         minimal wasted space.\n *      2. Placing bins on shelves with the closest matching height to minimize\n *         wasted vertical space.\n *      3. Creating new shelves as needed.\n *\n * ## Auto Resize\n * If enabled (`{autoResize: true}`), the container will automatically grow to\n * accommodate bins that don't fit within the current dimensions.\n *\n * ## Refcounting\n * Reference counting Bins keeps track of how many a bin has been allocated.\n * Use `.ref()` to increment and `.unref()` to decrement the count. When the\n * count reaches 0, the bin is freed.\n *\n * # Usage\n *\n * 1. Create a ShelfPack instance\n *    `const packer = new ShelfPack(width, height, options);`\n * 2. Pack bins\n *    `packer.pack(bins, options);` or `packer.packOne(width, height, id);`\n * 3. Retrieve a bin\n *    `packer.getBin(id);`\n * 4. Manage bin references\n *    `packer.ref(bin);` and `packer.unref(bin);`\n * 5. Resize the container\n *    `packer.resize(width, height);`\n * 6. Clear the container\n *    `packer.clear();`\n */\n\n/**\n * Options for configuring the ShelfPack instance.\n */\nexport interface ShelfPackOptions {\n  /**\n   * If true, the packer will automatically grow its dimensions to accommodate\n   * bins that don't fit.\n   */\n  autoResize?: boolean;\n}\n\nexport interface BinOptions {\n  inPlace?: boolean;\n  shrinkAfterPack?: boolean;\n}\n\nexport interface BinInterface {\n  id: string | number;\n  width: number;\n  height: number;\n  options?: BinOptions;\n}\n\n/**\n * Represents a rectangular area within the packer.\n */\nexport class Bin implements BinInterface {\n  /**\n   * Creates a new Bin instance.\n   * @param id Unique identifier for the bin.\n   * @param x Left coordinate of the bin.\n   * @param y Top coordinate of the bin.\n   * @param width Width of the bin.\n   * @param height Height of the bin.\n   * @param maxwidth Maximum width the bin can occupy.\n   * @param maxheight Maximum height the bin can occupy.\n   * @param refcount The number of references to this bin.\n   */\n  constructor(\n    public id: string | number,\n    public x: number,\n    public y: number,\n    public width: number,\n    public height: number,\n    public maxwidth: number = width,\n    public maxheight: number = height,\n    public refcount: number = 0,\n  ) {}\n}\n\n/**\n * Represents a horizontal row within the packer where bins can be placed.\n */\nexport class Shelf {\n  /**\n   * Creates a new Shelf instance.\n   * @param y Top coordinate of the shelf.\n   * @param width Width of the shelf.\n   * @param height Height of the shelf.\n   * @param x The initial X position on the shelf\n   */\n  constructor(\n    public y: number,\n    public width: number,\n    public height: number,\n    public x: number = 0,\n    public free: number = width,\n  ) {}\n\n  /**\n   * Attempts to allocate a bin on this shelf.\n   * @param width Width of the bin to allocate.\n   * @param height Height of the bin to allocate.\n   * @param id Unique identifier for the bin.\n   * @returns The allocated Bin, or null if allocation failed.\n   */\n  allocateBin(width: number, height: number, id: string | number): Bin | null {\n    if (width > this.free || height > this.height) {\n      return null;\n    }\n    const x = this.x;\n    this.x += width;\n    this.free -= width;\n    return new Bin(id, x, this.y, width, height, width, this.height);\n  }\n\n  /**\n   * Resizes the shelf to a new width.\n   * @param width The new width of the shelf.\n   */\n  resize(width: number): void {\n    this.free += width - this.width;\n    this.width = width;\n  }\n}\n\n/**\n * A bin packing algorithm that uses the Shelf Best Height Fit strategy.\n */\nexport class ShelfPack {\n  /**\n   * The maximum ID used for a bin.\n   */\n  public maxId: number;\n\n  /**\n   * Creates a new ShelfPack instance.\n   * @param width Initial width of the packer.\n   * @param height Initial height of the packer.\n   * @param options Optional configuration options.\n   */\n  constructor(\n    public width: number = 64,\n    public height: number = 64,\n    public options?: ShelfPackOptions,\n    public shelves: Shelf[] = [],\n    public freebins: Bin[] = [],\n    public stats: Record<number, number> = {},\n    public bins: Record<string | number, Bin> = {},\n    public autoResize: boolean = !!options?.autoResize,\n    maxId: number = 0,\n  ) {\n    this.maxId = maxId;\n  }\n\n  /**\n   * Packs multiple bins into the packer.\n   * @param bins An array of bins to pack. Each bin should have `width` and `height` properties.\n   * @param options Optional parameters.\n   * @param options.inPlace If true, modifies the input `bins` array in-place, adding `x`, `y`, and `id` properties to each bin.\n   * @returns An array of packed Bins.\n   */\n  pack(\n    bins: Bin[],\n    options: BinOptions = { inPlace: false, shrinkAfterPack: true },\n  ): Bin[] {\n    const updatedBins = bins as Bin[];\n\n    const results = [];\n    let width: number;\n    let height: number;\n    let id: string | number;\n    let allocation: Bin | null;\n\n    for (let i = 0; i < updatedBins.length; i++) {\n      width = updatedBins[i].width;\n      height = updatedBins[i].height;\n      id = updatedBins[i].id;\n\n      if (width && height) {\n        allocation = this.packOne(width, height, id);\n\n        if (!allocation) {\n          continue;\n        }\n\n        if (options.inPlace) {\n          updatedBins[i].x = allocation.x;\n          updatedBins[i].y = allocation.y;\n          updatedBins[i].id = allocation.id;\n        }\n        results.push(allocation);\n      }\n    }\n\n    if (options.shrinkAfterPack) {\n      this.shrink();\n    }\n\n    return results;\n  }\n\n  /**\n   * Packs a single bin into the packer.\n   * @param width Width of the bin to pack.\n   * @param height Height of the bin to pack.\n   * @param id Optional unique identifier for the bin. If not provided, a new ID will be generated.\n   * @returns The packed Bin, or null if the bin could not be packed.\n   */\n  packOne(width: number, height: number, id?: string | number): Bin | null {\n    const best: { freebin: number; shelf: number; waste: number } = {\n      freebin: -1,\n      shelf: -1,\n      waste: Infinity,\n    };\n    let y = 0;\n    let bin: Bin | undefined;\n    let shelf: Shelf | undefined;\n    let waste: number;\n    let i: number;\n    let finalId: string | number;\n\n    // If id was supplied, attempt a lookup.\n    if (typeof id === \"string\" || typeof id === \"number\") {\n      bin = this.getBin(id);\n      if (bin) {\n        // We packed this bin already.\n        this.incrementReferenceCount(bin);\n        return bin;\n      }\n      finalId = id;\n    } else {\n      finalId = ++this.maxId;\n    }\n\n    // First try to reuse a free bin.\n    for (i = 0; i < this.freebins.length; i++) {\n      bin = this.freebins[i];\n\n      // Exactly the right height and width, use it.\n      if (height === bin.maxheight && width === bin.maxwidth) {\n        return this.allocateFreeBin(i, width, height, finalId);\n      }\n      // Not enough height or width, skip it.\n      if (height > bin.maxheight || width > bin.maxwidth) {\n        continue;\n      }\n      // Extra height or width, minimize wasted area.\n      if (height <= bin.maxheight && width <= bin.maxwidth) {\n        waste = bin.maxwidth * bin.maxheight - width * height;\n        if (waste < best.waste) {\n          best.waste = waste;\n          best.freebin = i;\n        }\n      }\n    }\n\n    // Next find the best shelf.\n    for (i = 0; i < this.shelves.length; i++) {\n      shelf = this.shelves[i];\n      y += shelf.height;\n\n      // Not enough width on this shelf, skip it.\n      if (width > shelf.free) {\n        continue;\n      }\n      // Exactly the right height, pack it.\n      if (height === shelf.height) {\n        return this.allocShelf(i, width, height, finalId);\n      }\n      // Not enough height, skip it.\n      if (height > shelf.height) {\n        continue;\n      }\n      // Extra height, minimize wasted area.\n      if (height < shelf.height) {\n        waste = (shelf.height - height) * width;\n        if (waste < best.waste) {\n          best.freebin = -1;\n          best.waste = waste;\n          best.shelf = i;\n        }\n      }\n    }\n\n    if (best.freebin !== -1) {\n      return this.allocateFreeBin(best.freebin, width, height, finalId);\n    }\n\n    if (best.shelf !== -1) {\n      return this.allocShelf(best.shelf, width, height, finalId);\n    }\n\n    // No free bins or shelves. Add shelf.\n    if (height <= this.height - y && width <= this.width) {\n      shelf = new Shelf(y, this.width, height);\n      return this.allocShelf(\n        this.shelves.push(shelf) - 1,\n        width,\n        height,\n        finalId,\n      );\n    }\n\n    // No room for more shelves.\n    // If `autoResize` option is set, grow the sprite as follows:\n    //  * double whichever sprite dimension is smaller (`width1` or `height1`)\n    //  * if sprite dimensions are equal, grow width before height\n    //  * accommodate very large bin requests (big `width` or `height`)\n    if (this.autoResize) {\n      let height1: number, height2: number, width1: number, width2: number;\n\n      height1 = height2 = this.height;\n      width1 = width2 = this.width;\n\n      if (width1 <= height1 || width > width1) {\n        // Grow width.\n        width2 = Math.max(width, width1) * 2;\n      }\n      if (height1 < width1 || height > height1) {\n        // Grow height.\n        height2 = Math.max(height, height1) * 2;\n      }\n\n      this.resize(width2, height2);\n      return this.packOne(width, height, finalId); // Retry.\n    }\n\n    return null;\n  }\n\n  /**\n   * Allocates a bin by reusing an existing free bin.\n   * @param index The index of the free bin in the `freebins` array.\n   * @param width The width of the bin to allocate.\n   * @param height The height of the bin to allocate.\n   * @param id The unique identifier for the bin.\n   * @returns The allocated Bin.\n   */\n  private allocateFreeBin(\n    index: number,\n    width: number,\n    height: number,\n    id: string | number,\n  ): Bin {\n    const bin = this.freebins.splice(index, 1)[0];\n    const newBin = new Bin(\n      id,\n      bin.x,\n      bin.y,\n      width,\n      height,\n      bin.maxwidth,\n      bin.maxheight,\n      0,\n    );\n    this.bins[id] = newBin;\n    this.incrementReferenceCount(newBin);\n    return newBin;\n  }\n\n  /**\n   * Allocates a bin on an existing shelf.\n   * @param index The index of the shelf in the `shelves` array.\n   * @param width The width of the bin to allocate.\n   * @param height The height of the bin to allocate.\n   * @param id The unique identifier for the bin.\n   * @returns The allocated Bin.\n   */\n  private allocShelf(\n    index: number,\n    width: number,\n    height: number,\n    id: string | number,\n  ): Bin {\n    const shelf = this.shelves[index];\n    const bin = shelf.allocateBin(width, height, id);\n    if (bin === null) {\n      throw new Error(\"Failed to allocate bin on shelf.\");\n    }\n    this.bins[id] = bin;\n    this.incrementReferenceCount(bin);\n    return bin;\n  }\n\n  /**\n   * Shrinks the width/height of the sprite to the bare minimum.\n   * Since shelf-pack doubles first width, then height when running out of shelf space\n   * this can result in fairly large unused space both in width and height if that happens\n   * towards the end of bin packing.\n   */\n  shrink(): void {\n    if (this.shelves.length > 0) {\n      let width2 = 0;\n      let height2 = 0;\n\n      for (let j = 0; j < this.shelves.length; j++) {\n        const shelf = this.shelves[j];\n        height2 += shelf.height;\n        width2 = Math.max(shelf.width - shelf.free, width2);\n      }\n\n      this.resize(width2, height2);\n    }\n  }\n\n  /**\n   * Retrieves a packed bin by its ID.\n   * @param id The unique identifier of the bin.\n   * @returns The Bin, or undefined if no bin with the given ID is found.\n   */\n  getBin(id: string | number): Bin | undefined {\n    return this.bins[id];\n  }\n\n  /**\n   * Increments the reference count of a bin.\n   * @param bin The bin to increment the reference count of.\n   * @returns The new reference count of the bin.\n   */\n  incrementReferenceCount(bin: Bin): number {\n    if (++bin.refcount === 1) {\n      // A new Bin. record height in stats histogram.\n      this.stats[bin.height] = (this.stats[bin.height] ?? 0) + 1;\n    }\n\n    return bin.refcount;\n  }\n\n  /**\n   * Decrements the reference count of a bin.\n   * If the reference count reaches 0, the bin is added to the `freebins` list\n   * and removed from `bins`.\n   * @param bin The bin to decrement the reference count of.\n   * @returns The new reference count of the bin.\n   */\n  decrementReferenceCount(bin: Bin): number {\n    if (bin.refcount === 0) {\n      return 0;\n    }\n\n    if (--bin.refcount === 0) {\n      this.stats[bin.height]--;\n      delete this.bins[bin.id];\n      this.freebins.push(bin);\n    }\n\n    return bin.refcount;\n  }\n\n  /**\n   * Clears the packer, removing all bins and shelves.\n   */\n  clear(): void {\n    this.shelves = [];\n    this.freebins = [];\n    this.stats = {};\n    this.bins = {};\n    this.maxId = 0;\n  }\n\n  /**\n   * Resizes the packer to the given dimensions.\n   * @param width The new width of the packer.\n   * @param height The new height of the packer.\n   * @returns True if the resize was successful, false otherwise.\n   */\n  resize(width: number, height: number): boolean {\n    this.width = width;\n    this.height = height;\n    for (let i = 0; i < this.shelves.length; i++) {\n      this.shelves[i].resize(width);\n    }\n    return true;\n  }\n}\n"],"names":["Bin","id","x","y","width","height","maxwidth","maxheight","refcount","this","Shelf","free","prototype","allocateBin","resize","ShelfPack","options","shelves","freebins","stats","bins","autoResize","maxId","pack","inPlace","shrinkAfterPack","allocation","updatedBins","results","i","length","packOne","push","shrink","bin","shelf","waste","finalId","best","freebin","Infinity","getBin","incrementReferenceCount","allocateFreeBin","allocShelf","height1","width1","height2","width2","Math","max","index","splice","newBin","Error","j","_a","decrementReferenceCount","clear"],"mappings":"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"}