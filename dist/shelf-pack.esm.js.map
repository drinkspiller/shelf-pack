{"version":3,"file":"shelf-pack.esm.js","sources":["../../src/index.ts"],"sourcesContent":["/**\n * @fileoverview\n *\n * ShelfPack is a JavaScript library for efficiently packing rectangular items\n * (bins) into a larger container (sprite) using a bin packing algorithm. It\n * employs the Shelf Best Height Fit strategy to minimize wasted space.\n *\n * An Analogy: The Bookshelf\n *\n * Imagine a ShelfPack instance as managing a physical bookshelf:\n *\n *     - `ShelfPack` instance: entire bookshelf.\n *     - `this.shelves`: The horizontal shelves on the bookshelf.\n *     - `Bin` objects: The rectangular items (e.g., books) being placed on the\n *        shelves.\n *     - `this.freebins`: A box of \"available\" books that have been removed\n *        from the shelf and can be reused.\n *     - `this.bins`: A record of all the books currently placed on the\n *        bookshelf, and how many times each has been requested.\n *\n * # Core Concepts:\n *\n * ## Bins\n *  Bins (e.g. 'items', 'elements', 'books') represent an occupied space of a\n * certain size. Each bin has a width (`width`), height (`height`), and a unique\n * identifier (`id`). Think of `this.bins` as a bookshelf with books on it.\n *\n * ## Shelves\n * Shelves are _Horizontal Rows_ within the container where bins are placed.\n * New shelves are created as needed to accommodate bins that don't fit on\n * existing shelves. Think of `this.shelves` as, er, the 'shelves' on a\n * bookshelf.\n *\n * ## Freebins\n * Freebins are a list of previously allocated bins that have been released\n * (i.e. have `refcount === 0`) and are available for reuse. Think of `freebins`\n *  as books that were taken off the shelf and put into a special\n * \"available books\" box (`this.freebins`). The space these books recently\n * occupied can be checked for fit when another book is being placed on a shelf.\n * If it fits, the book can be placed there.\n *\n * ## Shelf Best Height Fit\n * The algorithm prioritizes:\n *      1. Reusing existing `freebins` if they are an exact match or have\n *         minimal wasted space.\n *      2. Placing bins on shelves with the closest matching height to minimize\n *         wasted vertical space.\n *      3. Creating new shelves as needed.\n *\n * ## Auto Resize\n * If enabled (`{autoResize: true}`), the container will automatically grow to\n * accommodate bins that don't fit within the current dimensions.\n *\n * ## Refcounting\n * Reference counting Bins keeps track of how many a bin has been allocated.\n * Use `.ref()` to increment and `.unref()` to decrement the count. When the\n * count reaches 0, the bin is freed.\n *\n * # Usage\n *\n * 1. Create a ShelfPack instance\n *    `const packer = new ShelfPack(width, height, options);`\n * 2. Pack bins\n *    `packer.pack(bins, options);` or `packer.packOne(width, height, id);`\n * 3. Retrieve a bin\n *    `packer.getBin(id);`\n * 4. Manage bin references\n *    `packer.ref(bin);` and `packer.unref(bin);`\n * 5. Resize the container\n *    `packer.resize(width, height);`\n * 6. Clear the container\n *    `packer.clear();`\n */\n\n/**\n * Options for configuring the ShelfPack instance.\n */\nexport interface ShelfPackOptions {\n  /**\n   * If true, the packer will automatically grow its dimensions to accommodate\n   * bins that don't fit.\n   */\n  autoResize?: boolean;\n}\n\nexport interface BinInterface {\n  id: string | number;\n  width: number;\n  height: number;\n  options?: { inPlace: boolean };\n}\n\n/**\n * Represents a rectangular area within the packer.\n */\nexport class Bin implements BinInterface {\n  id: string | number;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  maxwidth: number;\n  maxheight: number;\n  refcount: number;\n  /**\n   * Creates a new Bin instance.\n   * @param id Unique identifier for the bin.\n   * @param x Left coordinate of the bin.\n   * @param y Top coordinate of the bin.\n   * @param width Width of the bin.\n   * @param height Height of the bin.\n   * @param maxwidth Maximum width the bin can occupy.\n   * @param maxheight Maximum height the bin can occupy.\n   * @param refcount The number of references to this bin.\n   */\n  constructor(\n    id: string | number,\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    maxwidth: number = width,\n    maxheight: number = height,\n    refcount: number = 0,\n  ) {\n    this.id = id;\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.maxwidth = maxwidth;\n    this.maxheight = maxheight;\n    this.refcount = refcount;\n  }\n}\n\n/**\n * Represents a horizontal row within the packer where bins can be placed.\n */\nexport class Shelf {\n  y: number;\n  width: number;\n  height: number;\n  x: number;\n  free: number;\n  /**\n   * Creates a new Shelf instance.\n   * @param y Top coordinate of the shelf.\n   * @param width Width of the shelf.\n   * @param height Height of the shelf.\n   * @param x The initial X position on the shelf\n   */\n  constructor(y: number, width: number, height: number, x: number = 0) {\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.x = x;\n    this.free = width;\n  }\n\n  /**\n   * Attempts to allocate a bin on this shelf.\n   * @param width Width of the bin to allocate.\n   * @param height Height of the bin to allocate.\n   * @param id Unique identifier for the bin.\n   * @returns The allocated Bin, or null if allocation failed.\n   */\n  allocateBin(width: number, height: number, id: string | number): Bin | null {\n    if (width > this.free || height > this.height) {\n      return null;\n    }\n    const x = this.x;\n    this.x += width;\n    this.free -= width;\n    return new Bin(id, x, this.y, width, height, width, this.height);\n  }\n\n  /**\n   * Resizes the shelf to a new width.\n   * @param width The new width of the shelf.\n   */\n  resize(width: number): void {\n    this.free += width - this.width;\n    this.width = width;\n  }\n}\n\n/**\n * A bin packing algorithm that uses the Shelf Best Height Fit strategy.\n */\nexport class ShelfPack {\n  /**\n   * If true, the packer will automatically grow its dimensions to accommodate\n   * bins that don't fit.\n   */\n  autoResize: boolean;\n  /**\n   * The list of shelves in the packer.\n   */\n  shelves: Shelf[];\n  /**\n   * The list of free bins available for reuse.\n   */\n  freebins: Bin[];\n  /**\n   * Statistics about the packed bins.\n   */\n  stats: Record<number, number>;\n  /**\n   * A map of packed bins, indexed by their unique identifiers.\n   */\n  bins: Record<string | number, Bin>;\n  /**\n   * The maximum ID used for a bin.\n   */\n  maxId: number;\n  /**\n   * The current width of the packer\n   */\n  width: number;\n  /**\n   * The current height of the packer\n   */\n  height: number;\n  /**\n   * Creates a new ShelfPack instance.\n   * @param width Initial width of the packer.\n   * @param height Initial height of the packer.\n   * @param options Optional configuration options.\n   */\n  constructor(\n    width: number = 64,\n    height: number = 64,\n    options?: ShelfPackOptions,\n  ) {\n    const opts = options ?? {};\n    this.autoResize = !!opts.autoResize;\n    this.shelves = [];\n    this.freebins = [];\n    this.stats = {};\n    this.bins = {};\n    this.maxId = 0;\n    this.width = width;\n    this.height = height;\n  }\n\n  /**\n   * Packs multiple bins into the packer.\n   * @param bins An array of bins to pack. Each bin should have `width` and `height` properties.\n   * @param options Optional parameters.\n   * @param options.inPlace If true, modifies the input `bins` array in-place, adding `x`, `y`, and `id` properties to each bin.\n   * @returns An array of packed Bins.\n   */\n  /**\n   * Packs multiple bins into the packer.\n   * @param bins An array of bins to pack. Each bin should have `width` and `height` properties.\n   * @param options Optional parameters.\n   * @param options.inPlace If true, modifies the input `bins` array in-place, adding `x`, `y`, and `id` properties to each bin.\n   * @returns An array of packed Bins.\n   */\n  pack<T extends { inPlace?: boolean }>(\n    bins: Bin[],\n    options: T = {} as T,\n  ): Bin[] {\n    const updatedBins = bins as Bin[];\n\n    const results = [];\n    let width: number;\n    let height: number;\n    let id: string | number;\n    let allocation: Bin | null;\n\n    for (let i = 0; i < updatedBins.length; i++) {\n      width = updatedBins[i].width;\n      height = updatedBins[i].height;\n      id = updatedBins[i].id;\n\n      if (width && height) {\n        allocation = this.packOne(width, height, id);\n        if (!allocation) {\n          continue;\n        }\n        if (options.inPlace) {\n          updatedBins[i].x = allocation.x;\n          updatedBins[i].y = allocation.y;\n          updatedBins[i].id = allocation.id;\n        }\n        results.push(allocation);\n      }\n    }\n\n    this.shrink();\n\n    return results;\n  }\n\n  /**\n   * Packs a single bin into the packer.\n   * @param width Width of the bin to pack.\n   * @param height Height of the bin to pack.\n   * @param id Optional unique identifier for the bin. If not provided, a new ID will be generated.\n   * @returns The packed Bin, or null if the bin could not be packed.\n   */\n  packOne(width: number, height: number, id?: string | number): Bin | null {\n    const best: { freebin: number; shelf: number; waste: number } = {\n      freebin: -1,\n      shelf: -1,\n      waste: Infinity,\n    };\n    let y = 0;\n    let bin: Bin | undefined;\n    let shelf: Shelf | undefined;\n    let waste: number;\n    let i: number;\n    let finalId: string | number;\n\n    // If id was supplied, attempt a lookup.\n    if (typeof id === \"string\" || typeof id === \"number\") {\n      bin = this.getBin(id);\n      if (bin) {\n        // We packed this bin already.\n        this.incrementReferenceCount(bin);\n        return bin;\n      }\n      finalId = id;\n    } else {\n      finalId = ++this.maxId;\n    }\n\n    // First try to reuse a free bin.\n    for (i = 0; i < this.freebins.length; i++) {\n      bin = this.freebins[i];\n\n      // Exactly the right height and width, use it.\n      if (height === bin.maxheight && width === bin.maxwidth) {\n        return this.allocateFreeBin(i, width, height, finalId);\n      }\n      // Not enough height or width, skip it.\n      if (height > bin.maxheight || width > bin.maxwidth) {\n        continue;\n      }\n      // Extra height or width, minimize wasted area.\n      if (height <= bin.maxheight && width <= bin.maxwidth) {\n        waste = bin.maxwidth * bin.maxheight - width * height;\n        if (waste < best.waste) {\n          best.waste = waste;\n          best.freebin = i;\n        }\n      }\n    }\n\n    // Next find the best shelf.\n    for (i = 0; i < this.shelves.length; i++) {\n      shelf = this.shelves[i];\n      y += shelf.height;\n\n      // Not enough width on this shelf, skip it.\n      if (width > shelf.free) {\n        continue;\n      }\n      // Exactly the right height, pack it.\n      if (height === shelf.height) {\n        return this.allocShelf(i, width, height, finalId);\n      }\n      // Not enough height, skip it.\n      if (height > shelf.height) {\n        continue;\n      }\n      // Extra height, minimize wasted area.\n      if (height < shelf.height) {\n        waste = (shelf.height - height) * width;\n        if (waste < best.waste) {\n          best.freebin = -1;\n          best.waste = waste;\n          best.shelf = i;\n        }\n      }\n    }\n\n    if (best.freebin !== -1) {\n      return this.allocateFreeBin(best.freebin, width, height, finalId);\n    }\n\n    if (best.shelf !== -1) {\n      return this.allocShelf(best.shelf, width, height, finalId);\n    }\n\n    // No free bins or shelves. Add shelf.\n    if (height <= this.height - y && width <= this.width) {\n      shelf = new Shelf(y, this.width, height);\n      return this.allocShelf(\n        this.shelves.push(shelf) - 1,\n        width,\n        height,\n        finalId,\n      );\n    }\n\n    // No room for more shelves.\n    // If `autoResize` option is set, grow the sprite as follows:\n    //  * double whichever sprite dimension is smaller (`width1` or `height1`)\n    //  * if sprite dimensions are equal, grow width before height\n    //  * accommodate very large bin requests (big `width` or `height`)\n    if (this.autoResize) {\n      let height1: number, height2: number, width1: number, width2: number;\n\n      height1 = height2 = this.height;\n      width1 = width2 = this.width;\n\n      if (width1 <= height1 || width > width1) {\n        // Grow width.\n        width2 = Math.max(width, width1) * 2;\n      }\n      if (height1 < width1 || height > height1) {\n        // Grow height.\n        height2 = Math.max(height, height1) * 2;\n      }\n\n      this.resize(width2, height2);\n      return this.packOne(width, height, finalId); // Retry.\n    }\n\n    return null;\n  }\n\n  /**\n   * Allocates a bin by reusing an existing free bin.\n   * @param index The index of the free bin in the `freebins` array.\n   * @param width The width of the bin to allocate.\n   * @param height The height of the bin to allocate.\n   * @param id The unique identifier for the bin.\n   * @returns The allocated Bin.\n   */\n  private allocateFreeBin(\n    index: number,\n    width: number,\n    height: number,\n    id: string | number,\n  ): Bin {\n    const bin = this.freebins.splice(index, 1)[0];\n    const newBin = new Bin(\n      id,\n      bin.x,\n      bin.y,\n      width,\n      height,\n      bin.maxwidth,\n      bin.maxheight,\n      0,\n    );\n    this.bins[id] = newBin;\n    this.incrementReferenceCount(newBin);\n    return newBin;\n  }\n\n  /**\n   * Allocates a bin on an existing shelf.\n   * @param index The index of the shelf in the `shelves` array.\n   * @param width The width of the bin to allocate.\n   * @param height The height of the bin to allocate.\n   * @param id The unique identifier for the bin.\n   * @returns The allocated Bin.\n   */\n  private allocShelf(\n    index: number,\n    width: number,\n    height: number,\n    id: string | number,\n  ): Bin {\n    const shelf = this.shelves[index];\n    const bin = shelf.allocateBin(width, height, id);\n    if (bin === null) {\n      throw new Error(\"Failed to allocate bin on shelf.\");\n    }\n    this.bins[id] = bin;\n    this.incrementReferenceCount(bin);\n    return bin;\n  }\n\n  /**\n   * Shrinks the width/height of the sprite to the bare minimum.\n   * Since shelf-pack doubles first width, then height when running out of shelf space\n   * this can result in fairly large unused space both in width and height if that happens\n   * towards the end of bin packing.\n   */\n  shrink(): void {\n    if (this.shelves.length > 0) {\n      let width2 = 0;\n      let height2 = 0;\n\n      for (let j = 0; j < this.shelves.length; j++) {\n        const shelf = this.shelves[j];\n        height2 += shelf.height;\n        width2 = Math.max(shelf.width - shelf.free, width2);\n      }\n\n      this.resize(width2, height2);\n    }\n  }\n\n  /**\n   * Retrieves a packed bin by its ID.\n   * @param id The unique identifier of the bin.\n   * @returns The Bin, or undefined if no bin with the given ID is found.\n   */\n  getBin(id: string | number): Bin | undefined {\n    return this.bins[id];\n  }\n\n  /**\n   * Increments the reference count of a bin.\n   * @param bin The bin to increment the reference count of.\n   * @returns The new reference count of the bin.\n   */\n  incrementReferenceCount(bin: Bin): number {\n    if (++bin.refcount === 1) {\n      // A new Bin. record height in stats histogram.\n      this.stats[bin.height] = (this.stats[bin.height] | 0) + 1;\n    }\n\n    return bin.refcount;\n  }\n\n  /**\n   * Decrements the reference count of a bin.\n   * If the reference count reaches 0, the bin is added to the `freebins` list\n   * and removed from `bins`.\n   * @param bin The bin to decrement the reference count of.\n   * @returns The new reference count of the bin.\n   */\n  decrementReferenceCount(bin: Bin): number {\n    if (bin.refcount === 0) {\n      return 0;\n    }\n\n    if (--bin.refcount === 0) {\n      this.stats[bin.height]--;\n      delete this.bins[bin.id];\n      this.freebins.push(bin);\n    }\n\n    return bin.refcount;\n  }\n\n  /**\n   * Clears the packer, removing all bins and shelves.\n   */\n  clear(): void {\n    this.shelves = [];\n    this.freebins = [];\n    this.stats = {};\n    this.bins = {};\n    this.maxId = 0;\n  }\n\n  /**\n   * Resizes the packer to the given dimensions.\n   * @param width The new width of the packer.\n   * @param height The new height of the packer.\n   * @returns True if the resize was successful, false otherwise.\n   */\n  resize(width: number, height: number): boolean {\n    this.width = width;\n    this.height = height;\n    for (let i = 0; i < this.shelves.length; i++) {\n      this.shelves[i].resize(width);\n    }\n    return true;\n  }\n}\n"],"names":[],"mappings":"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"}